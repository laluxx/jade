use raylib
use GLFW.glfw3
use stdbool

fn sub(x:i32, y:i32) -> i32 {
    return x - y;
}

fn voidFunction() -> void {

}

fn boolFunction() -> bool {
    return true;
}

let x:f32 = 29; // TODO here make it 29.0

let st:str = "ciao";


#define COMPTIME 10;

type Point {
    x:i32
    y:i32
};

rec type Value {
    b:bool
    v:Value
}


let integer = 29;
let floating = 29.0;
let string = "text";
let character = 'a';
let boolean = true;
let anotherBoolean = false;

let const arr = [1, 2, 3];

let a = ['a'..'z'];

let n = [1..100];
let f = [1.0..100.0];


let ifarr:[_]:f32 = [1.0, 1.0, 2.0];
let tiiarr:[]i32 = [6.0, 7.0, 8.0];
let tiiarrr[]:i32 = [6.0, 7.0, 8.0];
let iarr[_]i32 = [3.0, 4.0, 5.0];
let farr:[] = [3.0, 4.0, 5.0];
let sarr[2] = ["two", "strings"];
let carr:[2] = ['a', 'b'];
let barr:[2] = [true, false];

let uarr[10]char;
let anarr:[10]:bool;
int arrr[3] = {1, 2, 3}; // C syntax always works in every context!




fn main() -> i32 {
    let variable:i32 = sub(2, 2); // NOTE This works somehow
    let x:i32 = 10;
    let y = 3;

    defer printf("Deferredf!\n"); // TODO Defers pop before return statements

    if x > 3 {
        printf("Hello World\n");
    }

    if (x > 3) {
        printf("Hello World\n");
    }


    if x > 3 printf("Hello World\n");
    if x == y printf("Hello World\n");
    if x >= y printf("Hello World\n");
    if x == y return 0;
    if x != y return 1;
    if x <= y return 1;
    if (x > 3) printf("Hello World\n");
    if boolFunction() return 1;


    // TODO Those still don't work
    // while (true) printf("Yes\n");
    // while true printf("Yes\n");
    // while boolFunction() printf("No\n");

    // for 10 printf("Hello, world\n");
    // for x printf("Hello, world\n");

    loop {
        println!("something");
        break;
    }

    
    sub(3, -1); // ANOTHER
    // Comment
    return 0;
}

fn add(x:i32, y:i32) -> i32 {
    return x + y;
}
